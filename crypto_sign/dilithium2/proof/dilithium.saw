/*
   This module implements the digital signature scheme Dilithium
   submitted to the NIST post-quantum project.

   See https://pq-crystals.org/dilithium/data/dilithium-specification.pdf
   Copyright (c) 2018-2021, Galois Inc.
   www.cryptol.net
   You can freely use this source code for educational purposes.
   Authors: Ajay Kumar Eeralla and Aaron Tomb
*/

/* From now on, I follow the following naming conventions:
* types, modules -- upper camel case
* constants -- upper flat case
* functions, properties -- camel case
* add a space after/before opening/closing bracket of lists, records
* add a space before and after an infix operator
*/

// Note: have to do this before llvm_load_module!
enable_lax_arithmetic;

//enable_experimental;
//enable_smt_array_memory_model;

dilithium2 <- llvm_load_module "../clean/bc/libdilithium2_clean.a.bc";
import "deps/cryptol-specs/Primitive/Asymmetric/Signature/Dilithium/Round2/DilithiumMedium.cry";
import "deps/cryptol-specs/Common/mod_arith.cry";
import "deps/cryptol-specs/Common/bv.cry";
import "DilithiumAux.cry";

let tm = crucible_term;

let verify m n ovs sat setup prover =
  crucible_llvm_unsafe_assume_spec m n setup;

let verify' = crucible_llvm_verify;

let assume m n ovs sat setup prover =
  crucible_llvm_unsafe_assume_spec m n setup;

let GLOBALS = do {
  crucible_alloc_global "zetas";
  crucible_alloc_global "zetas_inv";
  crucible_points_to (crucible_global "zetas") (crucible_global_initializer "zetas");
  crucible_points_to (crucible_global "zetas_inv") (crucible_global_initializer "zetas_inv");
  //crucible_points_to (crucible_global "KeccakF_RoundConstants") (crucible_global_initializer "KeccakF_RoundConstants");
};

let unint_prover nm unints =
  unint_yices unints;
  //assume_unsat;
  //offline_unint_smtlib2 unints nm;
  //quickcheck 100;

let prover nm = unint_prover nm [];

let prover_with_unints unints nm = offline_unint_smtlib2 unints nm;

let i8 = llvm_int 8;
let i32 = llvm_int 32;
let i64 = llvm_int 64;

let poly_type = llvm_array 1 (llvm_type "%struct.poly");
let polyvec_type n = llvm_array 1 (llvm_array n poly_type);

let ptr_to_fresh nm tp = do {
    x <- crucible_fresh_var nm tp;
    p <- crucible_alloc tp;
    crucible_points_to p (tm x);
    return (p, x);
};

let alloc_bytes n = crucible_alloc (llvm_array n i8);
let alloc_words n = crucible_alloc (llvm_array n i32);
let alloc_poly = crucible_alloc poly_type;
let alloc_polyvec n = crucible_alloc (polyvec_type n);

let fresh_poly nm = ptr_to_fresh nm poly_type;
let fresh_polyvec nm n = ptr_to_fresh nm (polyvec_type n);
let fresh_bytes nm n = ptr_to_fresh nm (llvm_array n i8);
let fresh_words nm n = ptr_to_fresh nm (llvm_array n i32);

let assign_fresh ty p nm = do {
    t <- crucible_fresh_var nm ty;
    crucible_points_to p (tm t);
};

let assign_fresh_poly = assign_fresh poly_type;
let assign_fresh_polyvec n = assign_fresh (polyvec_type n);
let assign_fresh_bytes n = assign_fresh (llvm_array n i8);

let prove_dilithium MODULE MODE = do {

// The following parameters from params.h

    let SEEDBYTES = 32;
    let CRHBYTES = 48;
    let N = 256;
    let NDIV2 = 128;
    let Q = 8380417;
    let QBITS = 23;
    let ROOTOFUNITY = 1753;
    let D = 14;
    let GAMMA1 = eval_int {{ ((`Q : [32]) - 1) / 16 }};
    let GAMMA2 = eval_int {{ (`GAMMA1 : [32]) / 2 }};
    let ALPHA = eval_int {{ 2 * (`GAMMA2 : [32]) }};
    let QINV = 4236238847;
    let M = eval_int {{ (2 ^^ 32) % `Q : [32] }}; //4193792
  
    // DilithiumII parameters

    let K = 4;
    let L = 3;
    let ETA = 6;
    let SETABITS = 4;
    let BETA = 325;
    let OMEGA = 80;

    let POLT1_SIZE_PACKED = eval_int {{ (`N : [32]) * ((`QBITS : [32]) - (`D : [32])) / 8 }};
    let POLT0_SIZE_PACKED = eval_int {{ (`N : [32]) * (`D : [32]) / 8  }}; // 448
    let POLETA_SIZE_PACKED = eval_int {{ ((`N : [32]) * (`SETABITS : [32])) / 8  }}; // 128
    let POLZ_SIZE_PACKED = eval_int {{ (`N : [32]) * ((`QBITS : [32]) - 3) / 8 }}; 
    let POLW1_SIZE_PACKED = eval_int {{ (`N : [32]) * 4 / 8 }};

    let CRYPTO_PUBLICKEYBYTES = eval_int {{ (`SEEDBYTES : [32]) + (`K : [32]) * (`POLT1_SIZE_PACKED : [32]) }};
    let CRYPTO_SECRETKEYBYTES =  eval_int  {{ 2 * (`SEEDBYTES : [32]) + (((`L : [32]) + (`K : [32])) * (`POLETA_SIZE_PACKED : [32])) + (`CRHBYTES:[32]) + (`K : [32])*(`POLT0_SIZE_PACKED : [32]) }}; //2800; //2*32 + (3+4) 128 + 48 + 4*448 
    let CRYPTO_BYTES = eval_int {{ (`L : [32])*(`POLZ_SIZE_PACKED : [32]) + ((`OMEGA : [32]) + (`K : [32])) + ((`N : [32])/8 + 8) }};

     let randombytes_setup = do {
      let sizetm = {{ 3 * `SEEDBYTES : [64] }};
      bp <- alloc_bytes (eval_int sizetm);
      crucible_execute_func [bp, tm sizetm];
      b <- crucible_fresh_var "b" (llvm_array (eval_int sizetm) i8);
      crucible_points_to bp (tm b);
      crucible_return (tm {{ 0 : [32] }});
    };
    // NB: we aren't going to verify this function
    randombytes_method_spec <- assume MODULE "randombytes" [] false randombytes_setup (prover "randombytes");

      let PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_setup = do {
      rp <- alloc_bytes 128;
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [rp, ap];
      res <- crucible_fresh_var "res" (llvm_array 128 (llvm_int 8));
      crucible_points_to rp (tm res);
      crucible_points_to rp (tm res);
      crucible_postcond {{ join res == join [ join [ xs@0 || (xs@1 << 4) | xs <- split p : [128][2][_] ] | p <- (map (\p -> map (\x -> drop`{24} x:[8]) p) a) ] }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_setup (prover "polyw1_pack");
    
      let PQCLEAN_DILITHIUM2_CLEAN_challenge_setup = do {
      cp <- alloc_poly;
      (mup, mu) <- fresh_bytes "mu" CRHBYTES;
      (w1p, w1) <- fresh_polyvec "w1" K;
      crucible_execute_func [cp, mup, w1p];
      //res <- crucible_fresh_var "res" (llvm_array 1 (llvm_type "%struct.poly"));
      //crucible_points_to arg0 (tm res);
      //crucible_postcond {{ zero == zero }};
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_challenge_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_challenge" [PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_challenge_setup (prover "challenge");

   /* let keccak_absorb_ones_spec n RATE  = do {
        s <- crucible_fresh_var "s" llvm_array 25 (llvm_int 64);
        sp <- crucible_alloc llvm_array 25 (llvm_int 64);
        crucible_points_to sp (tm s);
        r <- crucible_fresh_var "r" i32;
        m <- crucible_fresh_var "s" llvm_array n (llvm_int 8);
        mp <- crucible_alloc llvm_array n (llvm_int 8);
        crucible_points_to mp (tm m);
        mlen <- crucible_fresh_var "mlen" (llvm_int 64);
        //p <- crucible_fresh_var "p" i8;
        crucible_precond {{  r== (`RATE:[32]) /\ (mlen == (`n:[64]))}};
        crucible_execute_func [sp, (tm r), mp, (tm mlen), (tm {{0x1f:[8]}})];
        res <- crucible_fresh_var "res" state_t;
        crucible_points_to sp (tm {{res}});
        crucible_postcond {{ res == join (transpose ((transpose (split s:[5][5][64]))^(unflatten`{w=64} (join (pad`{r= (RATE*8)} (join [reverse x | x<-m]# 0b1111))))))  }} ;
    };*/

   /* let PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_setup = do {
      arg0_star <- crucible_fresh_var "arg0" (llvm_array 25 (llvm_type "%struct.shake128ctx"));
      //arg0_star <- crucible_fresh_var "arg0" (llvm_array 25 (llvm_int 64));
      arg0 <- crucible_alloc (llvm_array 25 (llvm_type "%struct.shake128ctx"));
     // arg0 <- crucible_alloc (llvm_array 25 (llvm_int 64));
      crucible_points_to arg0 (tm arg0_star);
      arg1_star <- crucible_fresh_var "arg1" (llvm_array 34 (llvm_int 8));
      arg1 <- crucible_alloc (llvm_array 34 (llvm_int 8));
      crucible_points_to arg1 (tm arg1_star);
      arg2 <- crucible_fresh_var "arg2" (llvm_int 16);
      crucible_execute_func [arg0, arg1, (tm arg2)];
      //crucible_postcond {{ True == True }};
    };
    PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init" [] false PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_setup (prover "shake128_stream_init");
*/

 let PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_setup = do {
      ap <- alloc_poly;
      (seedp, seed) <- fresh_bytes "seed" SEEDBYTES;
      nonce <- crucible_fresh_var "nonce" (llvm_int 16);
      crucible_execute_func [ap, seedp, tm nonce];
      //crucible_points_to ap (tm seed);
      assign_fresh_poly ap "a";
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_uniform" [/*PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_method_spec*/] false PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_setup (prover "Poly_uniform");

let PQCLEAN_DILITHIUM2_CLEAN_expand_mat_setup = do {
      matp <- crucible_alloc (llvm_array K (polyvec_type L));
      (rhop, rho) <- fresh_bytes "rho" SEEDBYTES;
      crucible_precond {{ rho != zero }};
      crucible_execute_func [matp, rhop];
      let res = {{ pmToIpm (expandA rho) }};
      crucible_points_to matp (tm res);
      //crucible_postcond {{ pmToIpm res == expandA rho }};
      //crucible_postcond {{ (map (\x -> map (\y -> map (\z -> safe_mod(`Q, z)) y)) x) (ipmToPm res)) == (expandA rho) }};
    };
     // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_expand_mat" [PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_expand_mat_setup (quickcheck 10); // (prover "expand_mat");

  let PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_setup = do {
      rp <- alloc_bytes POLZ_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ polyBound (0 - (`GAMMA1 - 1)) (`GAMMA1 - 1) a }};
      crucible_precond {{ standard32Poly a }};
      crucible_execute_func [rp, ap];
      let res = {{ polyZPack (ipToP a) }};
      crucible_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyz_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_setup (prover "Polyz_pack");

    let PQCLEAN_DILITHIUM2_CLEAN_pack_sig_setup = do {
      sigp <- alloc_bytes CRYPTO_BYTES;
      (zp, z) <- fresh_polyvec "z" L;
      (hp, h) <- fresh_polyvec "h" K;
      (cp, c) <- fresh_poly "c";
      crucible_precond {{ and [ and [ polyBound (0 - (`GAMMA1 - 1)) (`GAMMA1 - 1) p | p <- o ] | o <- z ] }};
      crucible_execute_func [sigp, zp, hp, cp];
      let zPV = {{ ipvToPv z }};
      let hPV = {{ ipvToPv h }};
      let cP = {{ ipToP c }};
      crucible_points_to sigp (tm {{ split (packSig (zPV, hPV, cP)) : [_][8] }});
    };
    // Status: applies override and symbolic simulation completes successfully but then hangs on even with an overnight run
    PQCLEAN_DILITHIUM2_CLEAN_pack_sig_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_pack_sig" [PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_pack_sig_setup (offline_smtlib2 "pack_sig"); //(prover "pack_sig");
                                                     //(prover_with_unints ["PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_method_spec"] "pack_sig"); //(quickcheck 2); //(prover "pack_sig");

    let PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_setup = do {
      a <- crucible_fresh_var "a" i64;
      crucible_precond {{ 0 <=$ a /\ a <=$ `Q * (2^^32) }};
      crucible_execute_func [tm a];
      let res = {{ montgomeryReduce a }};
      crucible_return (tm res);
      crucible_postcond {{ reducedBound res }};
      crucible_postcond {{ safe_product (res, `M) % `Q == safe_mod(`Q, a) }};
    };
    // Status: succeeds (quick check succeeds with the full postcondition and proof succeeds only with the first post condition and goes for ever for the full post condition)
    PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce" [] false PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_setup (prover "montgomeryReduce"); //(quickcheck 1000);

     let PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ reducedBoundPoly a }};
      crucible_execute_func [ap];
      let res = {{ nttInvImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ reducedBoundPoly res }};

    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont" [PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_setup (prover "invntt_frominvmont"); //(quickcheck 1); 
    
     let PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ reducedBoundPoly a }};
      crucible_execute_func [ap];
      let res = {{ nttInvImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ reducedBoundPoly res }};
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery" [PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_setup (prover "invntt_montgomery"); //(quickcheck 1); 

    let PQCLEAN_DILITHIUM2_CLEAN_ntt_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standard32Poly a }};
      crucible_execute_func [ap];
      let res = {{ nttImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ polyBound 0 (16 * `Q) res }};
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_ntt_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_ntt" [PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_ntt_setup (prover "ntt"); //(quickcheck 10);
    
  let PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standard32Poly a }};
      crucible_execute_func [ap];
      let res = {{ pToIP (ntt (ipToP a)) }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ polyBound 0 (16 * `Q) res }};
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_ntt" [PQCLEAN_DILITHIUM2_CLEAN_ntt_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_setup (quickcheck 1000); //(prover "Poly_ntt");

  let PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_setup = do {
      cp <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      crucible_precond {{ (polyBound 0 (22 * `Q) a) /\  (polyBound 0 (22 *` Q) b)}};
      crucible_execute_func [cp, ap, bp];
      let res = {{ pToIP (nttPolyMult (ipToP a) (ipToP b)) }};
      crucible_points_to cp (tm res);
      crucible_postcond {{ polyBound 0 (2 * `Q) res }};
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery" [PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_setup (quickcheck 100); //(prover "Poly_pointwise_invmontgomery");

    let PQCLEAN_DILITHIUM2_CLEAN_reduce32_setup = do {
      a <- crucible_fresh_var "a" i32;
      crucible_execute_func [tm a];
      let res = {{ reduce32 a }};
      crucible_return (tm res);
      crucible_postcond {{ reducedBound res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_reduce32_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_reduce32" [] false PQCLEAN_DILITHIUM2_CLEAN_reduce32_setup (prover "reduce32");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standard32Poly a }};
      crucible_execute_func [ap];
      let res = {{ polyReduceImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ reducedBoundPoly res }}; 
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_reduce" [PQCLEAN_DILITHIUM2_CLEAN_reduce32_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_setup (prover "Poly_reduce");

 let PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_setup = do {
      arg0_star <- crucible_fresh_var "arg0" (llvm_type "%struct.shake128ctx");
      arg0 <- crucible_alloc (llvm_type "%struct.shake128ctx");
      crucible_points_to arg0 (tm arg0_star);
      arg1_star <- crucible_fresh_var "arg1" (llvm_int 8);
      arg1 <- crucible_alloc (llvm_int 8);
      crucible_points_to arg1 (tm arg1_star);
      arg2 <- crucible_fresh_var "arg2" (llvm_int 16);
      crucible_execute_func [arg0, arg1, tm arg2];
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init" [] false PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_setup (prover "shake256_stream_init");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_setup = do {
      ap <- alloc_polyvec L;
      (seedp, seed) <- fresh_bytes "seed" CRHBYTES;
      nonce <- crucible_fresh_var "nonce" (llvm_int 16);
      crucible_execute_func [ap, seedp, tm nonce];
      crucible_points_to ap (tm {{ pvToIpv (expandMask (seed, nonce)) }});
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1" [PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_setup (prover "Poly_uniform_gamma1m1");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup = do {
      cp <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      crucible_precond {{ standard32Poly a /\ standard32Poly b }};
      crucible_execute_func [cp, ap, bp];
      crucible_points_to ap (tm a);
      crucible_points_to bp (tm b);
      let res = {{ polyAddImp a b }};
      crucible_points_to cp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_add" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup (prover "Poly_add");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup2 = do {
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      crucible_precond {{ standard32Poly a /\ standard32Poly b }};
      crucible_execute_func [ap, ap, bp];
      crucible_points_to bp (tm b);
      crucible_points_to ap (tm {{ polyAddImp a b }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec2 <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_add" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup2 (prover "Poly_add");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_setup = do {
      wp <-  alloc_polyvec K;
      (up, u) <- fresh_polyvec "u" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ standard32PolyVec u /\ standard32PolyVec v }};
      crucible_execute_func [wp, up, vp];
      crucible_points_to wp (tm {{ polyVecAddImp u v }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_add" [PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_setup (prover "Polyveck_add");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_setup = do {
      (ap, a) <- fresh_poly "a";
      b <- crucible_fresh_var "b" (llvm_int 32);
      crucible_precond {{ standard32Poly a }};
      crucible_precond {{ b == `GAMMA1 - `BETA /\ b == `GAMMA2 - `BETA }};
      crucible_execute_func [ap, tm b];
      let res = {{ zero # (infNormPoly (ipToP a)) : [32] }};
      crucible_return (tm {{ zero # [(res < b)] : [32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_setup (prover "Poly_chknorm");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      b <- crucible_fresh_var "b" (llvm_int 32);
      crucible_precond {{ standard32PolyVec a }};
      crucible_precond {{ b == `GAMMA1 - `BETA /\ b == `GAMMA2 - `BETA  }};
      crucible_execute_func [ap, tm b];
      let res = {{ zero # (infNormPolyVec (ipvToPv a)) : [32] }};
      crucible_return (tm {{ zero # [res < b] : [32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm" [PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_setup (prover "Polyveck_chknorm");

    let PQCLEAN_DILITHIUM2_CLEAN_csubq_setup = do {
      a <- crucible_fresh_var "a" i32;
      crucible_execute_func [tm a];
      let res = {{ csubq a }};
      crucible_return (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_csubq_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_csubq" [] false PQCLEAN_DILITHIUM2_CLEAN_csubq_setup (prover "csubq");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyCsubqImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_csubq" [PQCLEAN_DILITHIUM2_CLEAN_csubq_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_setup (prover "Poly_csubq");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyVecCsubqImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq" [PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_setup (prover "Polyveckcsubq");

    let PQCLEAN_DILITHIUM2_CLEAN_decompose_setup = do {
      a <- crucible_fresh_var "a" (llvm_int 32);
      a1p <- crucible_alloc (llvm_int 32);
      crucible_precond {{ standard32 a }};
      crucible_execute_func [tm a, a1p];
      let res = {{ decompose (drop a) }}; // (high_bits, low_bits)
      let highBits = {{ sext (res.0) : [32] }}; // high_bits
      let lowBits = {{ sext (res.1) : [32] }}; // low_bits
      crucible_points_to a1p (tm lowBits);
      crucible_return (tm highBits); // this return correct 
      crucible_postcond {{ decomposePc res.1 res.0 (drop a) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_decompose_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_decompose" [] false PQCLEAN_DILITHIUM2_CLEAN_decompose_setup (prover "decompose");
    
   let PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_setup = do {
      (a0p, a0) <- fresh_poly "a0";
      (a1p, a1) <- fresh_poly "a1";
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standard32Poly a }};
      crucible_execute_func [a1p, a0p, ap];
      let res = {{ decomposePoly (ipToP a) }};
      crucible_points_to a0p (tm {{ pToIP (res.1) }});
      crucible_points_to a1p (tm {{ pToIP (res.0) }});
      crucible_postcond {{ decomposePolyPc res.1 res.0 (ipToP a) }};
   };
    // Status: succeeds 
    // Assuming it for now to speed up verification 
    PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_decompose" [PQCLEAN_DILITHIUM2_CLEAN_decompose_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_setup (unint_prover "Poly_decompose" [/*"Decompose"*/]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_setup = do {
      (v0p, v0) <- fresh_polyvec "v0" K;
      (v1p, v1) <- fresh_polyvec "v1" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ standard32PolyVec v }};
      crucible_execute_func [v0p, v1p, vp];
      let res = {{ decomposePolyVec (ipvToPv v) }};
      crucible_points_to v0p (tm {{ pvToIpv (res.0) }});
      crucible_points_to v1p (tm {{ pvToIpv (res.1) }});
      crucible_postcond {{ decomposePolyVecPc res.1 res.0 (ipvToPv v) }};
    };
    // Status: succeeds
    // Assuming it for now to speed up verification 
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose" [PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_setup (unint_prover "Polyveck_decompose" ["decomposePoly"]);

  let PQCLEAN_DILITHIUM2_CLEAN_freeze_setup = do {
      a <- crucible_fresh_var "a" i32;
      crucible_precond {{ standard32 a }};
      crucible_execute_func [tm a];
      let res = {{ freeze a }};
      crucible_return (tm res);
      crucible_postcond {{ standard32 res }};
      crucible_postcond {{ res == safe_mod(`Q, a) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_freeze_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_freeze" [PQCLEAN_DILITHIUM2_CLEAN_reduce32_method_spec, PQCLEAN_DILITHIUM2_CLEAN_csubq_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_freeze_setup (prover "freeze");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standard32Poly a }};
      crucible_execute_func [ap];
      let res = {{ polyFreezeImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ standard32Poly res }};
    };
    // Status: succeeds
    // Assuming it for now to speed up verification 
    PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_freeze" [PQCLEAN_DILITHIUM2_CLEAN_freeze_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_setup (prover "Poly_freeze");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
       crucible_precond {{ standard32PolyVec a }};
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyVecFreezeImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze" [PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_setup (prover "Polyveck_freeze");

    let PQCLEAN_DILITHIUM2_CLEAN_make_hint_setup = do {
      arg0 <- crucible_fresh_var "arg0" (llvm_int 32);
      arg1 <- crucible_fresh_var "arg1" (llvm_int 32);
      crucible_precond {{ standard32 arg0 }};
      crucible_precond {{ standard32 arg1 }};
      crucible_execute_func [tm arg0, tm arg1];
      let res = {{ makeHintNew (drop arg0, drop arg1) }};
      crucible_return (tm {{ zext [res]:[32] }});
    };
    //Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_make_hint_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_make_hint" [] false PQCLEAN_DILITHIUM2_CLEAN_make_hint_setup (prover "make_hint");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_setup = do {
      hp <- alloc_poly;
      (a0p, a0) <- fresh_poly "a0";
      (a1p, a1) <- fresh_poly "a1";
      crucible_precond {{ standard32Poly a0 /\ standard32Poly a1 }};
      crucible_execute_func [hp, a0p, a1p];
      crucible_return (tm {{ zext (makeHintPolyNew (ipToP a0, ipToP a1)) : [32] }});
    };
    // Status: succeeds
    // Assuming it for now to speed up verification 
    PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint" [PQCLEAN_DILITHIUM2_CLEAN_make_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_setup (prover "Poly_make_hint");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_setup = do {
      hp <- alloc_polyvec K;
      (v0p, v0) <- fresh_polyvec "v0" K;
      (v1p, v1) <- fresh_polyvec "v1" K;
      crucible_precond {{ standard32PolyVec v0 /\ standard32PolyVec v1 }};
      crucible_execute_func [hp, v0p, v1p];
      crucible_return (tm {{ zext (makeHintPolyVecNew (ipvToPv v0, ipvToPv v1)) : [32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint" [PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_setup (prover "Polyveck_make_hint");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_setup = do {
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ standard32PolyVec v }};
      crucible_execute_func [vp];
      let res = {{ (pvToIpv (map ntt (ipvToPv v))) }};
      crucible_points_to vp (tm res);
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt" [PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_setup (quickcheck 100); //(prover "Polyveck_ntt");
    
    let PQCLEAN_DILITHIUM2_CLEAN_poly_sub_setup = do {
      cp <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      crucible_execute_func [cp, ap, bp];
      crucible_points_to ap (tm a);
      crucible_points_to bp (tm b);
      crucible_points_to cp (tm {{ polySubImp a b }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_sub_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_sub" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_sub_setup (prover "Poly_sub");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_setup = do {
      wp <- alloc_polyvec K;
      (up, u) <- fresh_polyvec "u" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ standard32PolyVec u /\ standard32PolyVec v }};
      crucible_execute_func [wp, up, vp];
      crucible_points_to wp (tm {{ polyVecSubImp u v }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub" [PQCLEAN_DILITHIUM2_CLEAN_poly_sub_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_setup (prover "Polyveck_sub");

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_setup = do {
      wp <- alloc_polyvec L;
      (up, u) <- fresh_polyvec "u" L;
      (vp, v) <- fresh_polyvec "v" L;
      crucible_precond {{ standard32PolyVec u /\ standard32PolyVec v }};
      crucible_execute_func [wp, up, vp];
      crucible_points_to wp (tm {{ polyVecAddImp u v }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add" [PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_setup (prover "Polyvecl_add");

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_setup = do {
      (ap, a) <- fresh_polyvec "a" L;
      b <- crucible_fresh_var "b" (llvm_int 32);
      crucible_precond {{ b == `GAMMA1 - `BETA /\ b == `GAMMA2 - `BETA  }};
      crucible_execute_func [ap, tm b];
      let res = {{ zero # (infNormPolyVec (ipvToPv a)) : [32] }};
      crucible_return (tm {{ zero # [res < b] : [32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm" [PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_setup (prover "Polyvecl_chknorm");

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_setup = do {
      (vp, v) <- fresh_polyvec "v" L;
      crucible_precond {{ standard32PolyVec v}};
      crucible_execute_func [vp];
      crucible_points_to vp (tm {{ polyVecFreezeImp v}});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze" [PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_setup (prover "Polyvecl_freeze");

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_setup = do {
      (vp, v) <- fresh_polyvec "v" L;
      crucible_precond {{ standard32PolyVec v }};
      crucible_execute_func [vp];
      crucible_points_to vp (tm {{ nttVecImp v }});
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt" [PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_setup (prover "Polyvecl_ntt"); //(quickcheck 10); 
    
    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_setup = do {
      wp <- alloc_poly;
      (up, u) <- fresh_polyvec "u" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ (polyVecBound 0 (22 * `Q) u) /\ (polyVecBoundGEq 0 (22 * `Q) v) }};
      crucible_execute_func [wp, up, vp];
      crucible_points_to wp (tm {{ pToIP (nttDotProduct (ipvToPv u) (ipvToPv v)) }});
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery" [PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec2, PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_setup (prover "Polyvecl_pointwise_acc_invmontgomery"); //(quickcheck 100);

    let PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_setup = do {
      rp <- alloc_poly;
      (ap, a) <- fresh_bytes "a" POLETA_SIZE_PACKED ;
      crucible_precond {{ and [ (byteBound (-`ETA) (`ETA) x) | x <- a ] }};// /\ (`n == `L \/ `n == `K) }}; // /\ (length a) == `n * `POLETA_SIZE_PACKED }};
      crucible_execute_func [rp, ap];
      let res = {{ unpackPolyEta a }};
      crucible_points_to rp (tm {{ pToIP res }});
      crucible_postcond {{ polyBound (`Q - `ETA) (`Q + `ETA) (pToIP res) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_setup (prover "Polyeta_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_setup = do {
      rp <- alloc_poly;
      (ap, a) <- fresh_bytes "a" POLT0_SIZE_PACKED;
      crucible_precond {{ and [ -2^^(`D-1) <$ c /\ c <=$ 2^^(`D-1) | c <- a ] }};
      crucible_execute_func [rp, ap];
      let res = {{ (polyT0Unpack a) }};
      crucible_points_to rp (tm {{ pToIP res }});
      crucible_postcond {{ polyBoundLEq (`Q - (2^^(`D - 1))) (`Q + (2^^(`D - 1))) (pToIP res) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_setup (prover "Polyt0_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_setup = do {
      rhop <- alloc_bytes SEEDBYTES;
      keyp <- alloc_bytes SEEDBYTES;
      trp <- alloc_bytes CRHBYTES;
      s1p <- alloc_polyvec L;
      s2p <- alloc_polyvec K;
      t0p <- alloc_polyvec K;
      (skp, sk) <- fresh_bytes "sk" CRYPTO_SECRETKEYBYTES; 
      //crucible_precond {{ standardBytes sk }};
      crucible_precond {{ and [ byteBound (-`ETA) (`ETA) x | x <- sk@@[112..1007] ] }};
      crucible_precond {{ and [ -2^^(`D-1) <$ c /\ c <=$ 2^^(`D-1) | c <- sk@@[1008..2799] ] }};
      crucible_execute_func [rhop, keyp, trp, s1p, s2p, t0p, skp];
      let res = {{ unpackSk sk }};
      crucible_points_to rhop (tm {{ res.0 }});
      crucible_points_to keyp (tm {{ res.1 }});
      crucible_points_to trp (tm {{ res.2 }});
      crucible_points_to s1p (tm {{ pvToIpv res.3 }});
      crucible_points_to s2p (tm {{ pvToIpv res.4 }});
      crucible_points_to t0p (tm {{ pvToIpv res.5 }});
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_unpack_sk" [PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_setup (prover "unpackSk");

    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_setup mlen = do {
      let siglen = CRYPTO_BYTES;
      sigp <- alloc_bytes siglen;
      siglenp <- crucible_alloc i64;
      (mp, m) <- fresh_bytes "m" mlen;
      (skp, sk) <- fresh_bytes "sk" CRYPTO_SECRETKEYBYTES;
      crucible_precond {{ `mlen >= 1 }};
      crucible_execute_func [sigp, siglenp, mp, tm {{ `mlen : [64] }}, skp];
      let sk_rec = {{ skTupleToRec (unpackSk sk) }};
      let sig = {{ split (packSig (sign`{mlen} sk_rec (join m))): [siglen][8] }};
      crucible_points_to sigp (tm sig);
      len <- crucible_fresh_var "len" i64;
      crucible_points_to siglenp (tm len);
      crucible_postcond {{ len == `CRYPTO_BYTES }};
      crucible_points_to mp (tm m);
      crucible_points_to skp (tm sk);
      crucible_return (tm {{ 0 : [32] }});
    };
    // Status: runs forever and depends on shake256 etc 
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature" 
                                                                  [ PQCLEAN_DILITHIUM2_CLEAN_challenge_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_pack_sig_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_method_spec 
                                                                  ] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_setup 1) (prover "crypto_sign_signature");

    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_setup mlen = do {
      let smlen = eval_int {{ `CRYPTO_BYTES + `mlen : [64] }};
      smp <- alloc_bytes smlen;
      smlenp <- crucible_alloc i64;
      (mp, m) <- fresh_bytes "m" mlen;
      (skp, sk) <- fresh_bytes "sk" CRYPTO_SECRETKEYBYTES;
      crucible_precond {{ `mlen >= 1 }};
      crucible_execute_func [smp, smlenp, mp, tm {{ `mlen : [64] }}, skp];
      let sk_rec = {{ skTupleToRec (unpackSk sk) }};
      let sm = {{ split (cryptoSign sk_rec (join m)) : [smlen][8] }};
      crucible_points_to smp (tm sm);
      len <- crucible_fresh_var "len" i64;
      crucible_points_to smlenp (tm len);
      crucible_postcond {{ len == `smlen }};
      crucible_points_to mp (tm m);
      crucible_points_to skp (tm sk);
      crucible_return (tm {{ 0 : [32] }});
    };
    // Status: runs forever
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign" [PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_method_spec] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_setup 1) (prover "crypto_sign");

    let PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_setup = do {
      rp <- alloc_bytes POLT1_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      // the input coefficients are in { 0,..., 2^^9-1 }
      crucible_precond {{ polyBoundGEq 0 512 a }};
      crucible_execute_func [rp, ap];
      crucible_points_to rp (tm {{ split (polyT1Pack (ipToP a)):[_][8] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_setup (prover "Polyt1_pack");

    let PQCLEAN_DILITHIUM2_CLEAN_pack_pk_setup = do {
      pkp <- alloc_bytes CRYPTO_PUBLICKEYBYTES;
      (rhop, rho) <- fresh_bytes "rho" SEEDBYTES;
      (t1p, t1) <- fresh_polyvec "t1" K;
      crucible_precond {{ standard32PolyVec t1 }};
      crucible_precond {{ polyVecBoundGEq 0 512 t1 }};
      crucible_execute_func [pkp, rhop, t1p];
      crucible_points_to pkp (crucible_term {{ packPkImp rho t1 }});

    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_pack_pk_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_pack_pk" [PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_pack_pk_setup (prover "packPk");

    let PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_setup = do {
      rp <- alloc_bytes POLETA_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ polyBound (`Q - `ETA) (`Q + `ETA) a }};
      crucible_execute_func [rp, ap];
      let res = {{ packPolyEtaImp a }};
      crucible_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_setup (prover "Polyeta_pack");

    let PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_setup = do {
      rp <- alloc_bytes POLT0_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ polyBoundLEq (0 - (2^^(`D - 1))) (2^^(`D - 1)) a }};
      crucible_execute_func [rp, ap];
      let res = {{ split (polyT0Pack (ipToP a)):[_][8] }};
      crucible_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_setup (prover "Polyt0_pack");

  let PQCLEAN_DILITHIUM2_CLEAN_pack_sk_setup = do {
      skp <- alloc_bytes CRYPTO_SECRETKEYBYTES; 
      (rhop, rho) <- fresh_bytes "rho" SEEDBYTES;
      (keyp, key) <- fresh_bytes "key" SEEDBYTES;
      (trp, tr) <- fresh_bytes "tr" CRHBYTES;
      (s1p, s1) <- fresh_polyvec "s1" L;
      (s2p, s2) <- fresh_polyvec "s2" K;
      (t0p, t0) <- fresh_polyvec "t0" K;
      crucible_precond {{ polyVecBound (`Q - `ETA) (`Q + `ETA) s1 }};
      crucible_precond {{ polyVecBound (`Q - `ETA) (`Q + `ETA) s2 }};
      crucible_precond {{ polyVecBoundLEq (0 - (2^^(`D - 1))) (2^^(`D - 1)) t0 }};
      crucible_execute_func [skp, rhop, keyp, trp, s1p, s2p, t0p];
      let res = {{ split (packSk rho key tr (ipvToPv s1) (ipvToPv s2) (ipvToPv t0)) :[_][8] }};
      crucible_points_to skp (tm res);
    };
    // Status: succeeds
    // Assuming it for now to speed up verification of other functions
    PQCLEAN_DILITHIUM2_CLEAN_pack_sk_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_pack_sk" [PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_pack_sk_setup (prover "pack_sk");
    let PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_setup = do {
      (ap, a) <- fresh_poly "a";
      (seedp, seed) <- fresh_bytes "seed" SEEDBYTES;
      nonce <- crucible_fresh_var "nonce" (llvm_int 16);
      //crucible_precond {{ standardBytes seed }};
      crucible_execute_func [ap, seedp, tm nonce];
      //(_, res) <- fresh_poly "res";
      //crucible_points_to ap (tm res);
      crucible_points_to ap (tm {{ pToIP (polyUniformEta seed nonce)}});
      //assign_fresh_poly ap "a";
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta" [/*PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_method_spec*/] false PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_setup (prover "Poly_uniform_eta");

    let PQCLEAN_DILITHIUM2_CLEAN_power2round_setup = do {
      a <- crucible_fresh_var "a" (llvm_int 32);
      a0p <- crucible_alloc (llvm_int 32);
      crucible_precond {{ standard32 a }};
      crucible_execute_func [tm a, a0p];
      let res = {{ power2Round (drop a) }};
      let a0 = {{ sext (res.1) : [32] }};
      let a1 = {{ sext (res.0) : [32] }};
      crucible_points_to a0p (tm {{ `Q + a0 }});
      crucible_return (tm {{ a1 }});
      crucible_postcond {{ a % `Q == a1*(2^^`D) + a0 }};
      crucible_postcond {{ (0 - 2)^^(`D - 1) <$ a0 }};
      crucible_postcond {{ a0 <=$ 2^^(`D - 1) }};
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_power2round_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_power2round" [] false PQCLEAN_DILITHIUM2_CLEAN_power2round_setup (prover "power2round");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_setup = do {
      a1p <- alloc_poly;
      a0p <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standard32Poly a }};
      crucible_execute_func [a1p, a0p, ap];
      let res = {{ polyPower2Round (ipToP a) }};
      crucible_points_to a0p (tm {{ addQToPoly (res.1) }});
      crucible_points_to a1p (tm {{ pToIP (res.0) }});
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_power2round" [PQCLEAN_DILITHIUM2_CLEAN_power2round_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_setup (unint_prover "Poly_power2round" ["Power2Round"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_setup = do {
      a0p <- alloc_polyvec K;
      a1p <- alloc_polyvec K;
      (ap, a) <- fresh_polyvec "a" K;
      crucible_precond {{ standard32PolyVec a }};
      crucible_execute_func [a1p, a0p, ap];
      let res = {{ power2RoundPolyVec (ipvToPv a) }};
      crucible_points_to a0p (tm {{ addQToPolyVec (res.1) }});
      crucible_points_to a1p (tm {{ pvToIpv (res.0) }});
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round" [PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_setup (unint_prover "Polyveck_power2round" ["polyPower2Round"]);
    
    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair_setup = do {
      pkp <- alloc_bytes CRYPTO_PUBLICKEYBYTES;
      skp <- alloc_bytes 2800; //CRYPTO_SECRETKEYBYTES;
      let sbytes = eval_int {{ 3 * `SEEDBYTES : [8] }};
      (seedp, seed) <- fresh_bytes "seed" sbytes;
      //crucible_precond {{ standardBytes seed }};
      crucible_execute_func [pkp, skp];
      let res = {{ gen (join seed) }};
      let pk = {{ res.0 }};
      let sk = {{ res.1 }};
      let pk = {{ packPk (split pk.rho) pk.t1 }};
      let sk = {{ packSk (split sk.rho) (split sk.key) (split sk.tr) sk.s1 sk.s2 sk.t0 }};
      //pk <- crucible_fresh_var "pk" (llvm_array CRYPTO_PUBLICKEYBYTES i8);
      //sk <- crucible_fresh_var "pk" (llvm_array CRYPTO_SECRETKEYBYTES i8);
      crucible_points_to pkp (tm {{ split pk : [_][8] }});
      crucible_points_to skp (tm {{ split sk : [_][8] }});
      crucible_return (tm {{ 0 : [32] }});
    };
    // NB: we aren't going to verify this function as it uses random seed.
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair" [ PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec, 
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_pack_pk_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_pack_sk_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec,
                                                                                                                                randombytes_method_spec 
                                                                                                                              ] false PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair_setup (prover "keypair");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_precond {{ reducedBoundPolyVec a }};
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ nttInvVecImp a }});
    };
    // Status: unknown
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery" [PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_setup (prover "Polyveck_invntt_montgomery");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_precond {{ standard32PolyVec a }};
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyVecReduceImp a }});
      crucible_postcond {{ reducedBoundPolyVec a }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce" [PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_setup (prover "Polyveck_reduce");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyShiftlImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_setup (prover "Poly_shiftl");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ [polyVecShiftlImp (a@0)] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl" [PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_setup (prover "Polyveck_shiftl");

    let PQCLEAN_DILITHIUM2_CLEAN_use_hint_setup = do {
      arg0 <- crucible_fresh_var "arg0" (llvm_int 32);
      arg1 <- crucible_fresh_var "arg1" (llvm_int 32);
      crucible_precond {{ standard32 arg0  }};
      crucible_precond {{ arg1 == 0 \/ arg1 == 1}}; 
      crucible_execute_func [tm arg0, tm arg1];
      crucible_return (tm {{ zext (useHint (drop arg0, drop arg1)):[32]}});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_use_hint_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_use_hint" [PQCLEAN_DILITHIUM2_CLEAN_decompose_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_use_hint_setup (prover "use_hint");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_setup = do {
      ap <- alloc_poly;
      (bp, b) <- fresh_poly "b";
      (hp, h) <- fresh_poly "h";
      crucible_precond {{ standard32Poly b }};
      crucible_execute_func [ap, bp, hp];
      crucible_points_to ap (tm {{ pToIP (useHintPoly (ipToP b) (ipToP h)) }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint" [PQCLEAN_DILITHIUM2_CLEAN_use_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_setup (prover "Poly_use_hint");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_setup = do {
      wp <- alloc_polyvec K;
      (up, u) <- fresh_polyvec "u" K;
      (hp, h) <- fresh_polyvec "h" K;
      crucible_precond {{ standard32PolyVec u }}; 
      crucible_execute_func [wp, up, hp]; 
      crucible_points_to wp (tm {{pvToIpv (useHintPolyVec (ipvToPv u, ipvToPv h))}});
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint" [PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_setup (prover "Polyveck_use_hint");
    
    let PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_setup = do {
      rp <- alloc_poly;
      (ap, a) <- fresh_bytes "a" POLT1_SIZE_PACKED; 
      crucible_precond{{ standardBytes a }};
      crucible_execute_func [rp, ap];
      let res = {{ pToIP (polyT1Unpack a) }};
      crucible_points_to rp (tm res);
      crucible_postcond {{ standard32Poly res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_setup (prover "Polyt1_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_setup = do {
      rhop <- alloc_bytes SEEDBYTES;
      t1p <- alloc_polyvec K;
      (pkp, pk) <- fresh_bytes "pk" CRYPTO_PUBLICKEYBYTES;
      crucible_precond {{ standardBytes (drop`{SEEDBYTES} pk) }};
      crucible_execute_func [rhop, t1p, pkp];
      let rho = {{ (unpackPk pk).0 }};
      let t1 = {{ pvToIpv (unpackPk pk).1 }};
      crucible_points_to rhop (tm rho);
      crucible_points_to t1p (tm t1);
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_unpack_pk" [PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_setup (prover "unpackPk");

    let PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_setup = do {
      rp <-  alloc_poly; 
      (ap, a) <- fresh_bytes "a" POLZ_SIZE_PACKED;
      crucible_precond {{ standardBytes a }};
      crucible_execute_func [rp, ap];
      let res = {{ pToIP (polyZUnpack a) }};
      crucible_points_to rp (tm res);
      crucible_postcond {{ standard32Poly res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_method_spec <- verify' MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_setup (prover "Polyz_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_setup = do {
      zp <- alloc_polyvec L;
      hp <- alloc_polyvec K;
      cp <- alloc_poly;
      (sigp, sig) <- fresh_bytes "sig" CRYPTO_BYTES;
      crucible_precond {{ standardBytes (sig@@[0..(L - 1) * POLZ_SIZE_PACKED - 1]) }};
      crucible_execute_func [ zp, hp, cp, sigp ];
      crucible_points_to zp (tm {{ pvToIpv (unpackSig sig).0 }});
      crucible_points_to hp (tm {{ pvToIpv (unpackSig sig).1 }});
      crucible_points_to cp (tm {{ pToIP (unpackSig sig).2 }});
    };
    // Status: applies override and symbolic simulation completes successfully but then hangs on even with an overnight run
    // assume it for now
    PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_unpack_sig" [PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_setup (assume_unsat); //(prover "unpack_sig");
                                                     //(prover_with_unints ["PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_method_spec"] "unpack_sig");
    
     let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_setup mlen = do {
      let siglen = CRYPTO_BYTES;
      (sigp, sig) <- fresh_bytes "sig" siglen;
      (mp, m) <- fresh_bytes "m" mlen;
      (pkp, pk) <- fresh_bytes "pk" CRYPTO_PUBLICKEYBYTES;
      crucible_precond {{ standardBytes (drop`{SEEDBYTES} pk) /\ standardBytes (sig@@[0..(L - 1) * POLZ_SIZE_PACKED - 1]) }};
      crucible_execute_func [sigp, tm {{ `siglen : [64] }}, mp, tm {{ `mlen : [64] }}, pkp];
      let res = {{ verify (pkBytesToRec pk) (join m) (unpackSig sig) }};
      crucible_return (tm {{ if res then zero else ~zero : [32] }});
    };
    // Status: fails applying override `unpack_sig`
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify" [PQCLEAN_DILITHIUM2_CLEAN_challenge_method_spec, PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec, PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec, PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec, PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_method_spec, PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_method_spec] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_setup 1) (prover "crypto_sign_verify");

    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open_setup mlen = do {
      let smlen = eval_int {{ `CRYPTO_BYTES + `mlen : [64] }}; 
      mp <- alloc_bytes mlen;
      mlenp <- crucible_alloc i64;
      (smp, sm) <- fresh_bytes "sm" smlen;
      (pkp, pk) <- fresh_bytes "pk" CRYPTO_PUBLICKEYBYTES;
      crucible_precond {{ standardBytes (drop`{SEEDBYTES} pk) /\ standardBytes (sm@@[0..(L - 1) * POLZ_SIZE_PACKED - 1]) }};
      crucible_execute_func [mp, mlenp, smp, (tm {{ `smlen : [64] }}), pkp];
      let res = {{ open (pkBytesToRec pk) sm }};
      crucible_return (tm {{ if res then zero else ~zero : [32] }});
    };
    // Status: counter example
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open" [PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_method_spec] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open_setup 1) (prover "crypto_sign_open");
    
    return ();
};

prove_dilithium dilithium2 1;
