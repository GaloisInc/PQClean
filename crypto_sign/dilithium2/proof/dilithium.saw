/*
   This module implements the digital signature scheme Dilithium
   submitted to the NIST post-quantum project.

   See https://pq-crystals.org/dilithium/data/dilithium-specification.pdf
   Copyright (c) 2018-2021, Galois Inc.
   www.cryptol.net
   You can freely use this source code for educational purposes.
   Authors: Ajay Kumar Eeralla and Aaron Tomb
*/

// Note: have to do this before llvm_load_module!
enable_lax_arithmetic;

enable_experimental;
//enable_smt_array_memory_model;

dilithium2 <- llvm_load_module "../clean/bc/libdilithium2_clean.a.bc";
import "deps/cryptol-specs/Primitive/Asymmetric/Signature/Dilithium/Round2/DilithiumMedium.cry";
import "deps/cryptol-specs/Common/mod_arith.cry";
import "deps/cryptol-specs/Common/bv.cry";
import "DilithiumAux.cry";

let tm = crucible_term;
let toInt = eval_int;

/*
// To allow us to focus on a single function
let verify m n ovs sat setup prover =
  if eval_bool {{ ((n # zero) : [80][_]) == ("PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint" # zero) }}
  then crucible_llvm_verify m n ovs sat setup prover
  else crucible_llvm_unsafe_assume_spec m n setup;
  */

// For functions we're going to verify
let verify = llvm_verify;


// For functions we're not going to verify
let assume m n ovs sat setup prover =
  crucible_llvm_unsafe_assume_spec m n setup;

// For functions we're going to verify, but haven't finished yet
let temp_assume = assume;

// For functions that do succeed but are slow.
let slow_verify = verify;

let unint_prover nm unints =
  unint_yices unints;
  //assume_unsat;
  //offline_unint_smtlib2 unints nm;
  //quickcheck 100;

let prover nm = unint_prover nm [];

let prover_with_unints unints nm = offline_unint_smtlib2 unints nm;

let i8 = llvm_int 8;
let i16 = llvm_int 16;
let i32 = llvm_int 32;
let i64 = llvm_int 64;

let poly_type = llvm_array 1 (llvm_type "%struct.poly");
let polyvec_type n = llvm_array 1 (llvm_array n poly_type);

// state type in keccak 
let state_type = llvm_array 26 i64;

// shake128incctx and shake256incctx are same
let shake128incctx_type = llvm_array 1 (llvm_type "%struct.shake128incctx");
let shake256incctx_type = shake128incctx_type;
// Give a common name that works for both the cases
let incctx_type = shake256incctx_type;

let ptr_to_fresh nm tp = do {
    x <- crucible_fresh_var nm tp;
    p <- crucible_alloc tp;
    crucible_points_to p (tm x);
    return (p, x);
};

let alloc_bytes n = crucible_alloc (llvm_array n i8);
let alloc_smt_bytes n = do {
    p <- crucible_alloc (llvm_array n i8);
    x <- llvm_fresh_cryptol_var "x" {| ByteArray |};
    llvm_points_to_array_prefix p x {{ `n : [64] }};
    return p;
};
let alloc_words n = crucible_alloc (llvm_array n i32);
let alloc_poly = crucible_alloc poly_type;
let alloc_polyvec n = crucible_alloc (polyvec_type n);
let alloc_state = crucible_alloc (state_type);
let alloc_incctx = crucible_alloc (incctx_type);

let fresh_poly nm = ptr_to_fresh nm poly_type;
let fresh_polyvec nm n = ptr_to_fresh nm (polyvec_type n);
let fresh_bytes nm n = ptr_to_fresh nm (llvm_array n i8);
let fresh_words nm n = ptr_to_fresh nm (llvm_array n i32);
let fresh_incctx nm = ptr_to_fresh nm incctx_type;
let fresh_state nm = ptr_to_fresh nm state_type;

let assign_fresh ty p nm = do {
    t <- crucible_fresh_var nm ty;
    crucible_points_to p (tm t);
};

let assign_fresh_poly = assign_fresh poly_type;
let assign_fresh_polyvec n = assign_fresh (polyvec_type n);
let assign_fresh_bytes n = assign_fresh (llvm_array n i8);
let assign_fresh_shake128ctx = assign_fresh shake128incctx_type;
let assign_fresh_shake256incctx = assign_fresh shake256incctx_type;
let assign_fresh_state = assign_fresh state_type;

let prove_dilithium MODULE MODE = do {
    // Parameters imported from Cryptol module
    let SEEDBYTES = toInt {{ `SeedBytes : [32] }};
    let CRHBYTES = toInt {{ `CrhBytes : [32] }};
    //let N = 256;
    //let NDIV2 = 128;
    let Q = toInt {{ `Q : [32] }}; //8380417;
    let QBITS = toInt {{ `QBits : [32] }}; //23;
    //let ROOTOFUNITY = 1753;
    let D = toInt {{ `D : [32] }}; //14;
    let GAMMA1 = toInt {{ ((`Q : [32]) - 1) / 16 }};
    let GAMMA2 = toInt {{ (`GAMMA1 : [32]) / 2 }};
    let ALPHA = toInt {{ 2 * (`GAMMA2 : [32]) }};
    //let QINV = 4236238847;
    let M = toInt {{ (2 ^^ 32) % `Q : [32] }}; //4193792
    let K = toInt {{ `K : [8] }} ;
    let L = toInt {{ `L : [8] }};
    let OMEGA_AND_K = toInt {{ `Omega + `K : [32] }};
    let ETA = toInt {{ ETA : [QBits] }};
    let SETABITS = toInt {{ `SetaBits : [8] }};
    let BETA = toInt {{ BETA : [QBits] }};
    let OMEGA = toInt {{ `Omega : [32] }};
    let POLT1_SIZE_PACKED = toInt {{ `PolT1SizePacked : [32] }}; 
    let POLT0_SIZE_PACKED = toInt {{ `PolT0SizePacked : [32] }}; 
    let POLETA_SIZE_PACKED = toInt {{ `PolEtaSizePacked : [32] }}; 
    let POLZ_SIZE_PACKED = toInt {{ `PolZSizePacked : [32] }}; 
    let POLW1_SIZE_PACKED = POLETA_SIZE_PACKED; 
    let CRYPTO_PUBLICKEYBYTES = toInt {{ `CryptoPublicKeyBytes : [32] }}; 
    let CRYPTO_SECRETKEYBYTES =  toInt {{ `CryptoSecretKeyBytes : [32] }}; 
    let CRYPTO_BYTES = toInt {{ `SigSizePacked : [32] }}; 
    let SHAKE256_RATE = 136;

     let randombytes_setup = do {
      let nb = toInt {{ 3 * `SEEDBYTES : [64] }};
      bp <- alloc_bytes nb;
      crucible_execute_func [bp, tm {{ `nb : [64] }}];
      b <- crucible_fresh_var "b" (llvm_array nb i8);
      crucible_points_to bp (tm b);
      crucible_return (tm {{ 0 : [32] }});
    };
    // NB: we aren't going to verify this function
    randombytes_method_spec <- assume MODULE "randombytes" [] false randombytes_setup (prover "randombytes");

      let PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_setup = do {
      rp <- alloc_bytes (toInt {{ `POLW1_SIZE_PACKED : [32] }});
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [rp, ap];
      let res = {{ split (join [ join [ xs@0 || (xs@1 << 4) | xs <- split p : [128][2][_] ] | p <- (map (\p -> map (\x -> drop`{24} x:[8]) p) a) ]) : [POLW1_SIZE_PACKED][8] }};
      crucible_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_setup (prover "polyw1_pack");
    
      let PQCLEAN_DILITHIUM2_CLEAN_challenge_setup = do {
      cp <- alloc_poly;
      (mup, mu) <- fresh_bytes "mu" CRHBYTES;
      (w1p, w1) <- fresh_polyvec "w1" K;
      crucible_execute_func [cp, mup, w1p];
      //res <- crucible_fresh_var "res" (llvm_array 1 (llvm_type "%struct.poly"));
      //crucible_points_to arg0 (tm res);
      //crucible_postcond {{ zero == zero }};
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_challenge_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_challenge" [PQCLEAN_DILITHIUM2_CLEAN_polyw1_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_challenge_setup (prover "challenge");

let KeccakF1600_StatePermute_setup  = do {
	(stp, st) <- fresh_state "st";
	crucible_execute_func [stp];
	c <- crucible_fresh_var "c" state_type;
	crucible_points_to stp (tm c);
	//crucible_postcond {{ c == (join (transpose (Keccak_f (transpose (split s): [5][5][64])))) }};	
};
KeccakF1600_StatePermute_method_spec <- assume MODULE "KeccakF1600_StatePermute" [] false KeccakF1600_StatePermute_setup (prover "keccakF1600_StatePermute");

// keccak_inc_init
let keccak_inc_init_setup  = do {
  (stp, st) <- fresh_state "st";
  crucible_execute_func [stp];
  c <- crucible_fresh_var "c" state_type;
  crucible_points_to stp (tm c);
  //crucible_postcond {{ c == (join (transpose (Keccak_f (transpose (split s): [5][5][64])))) }};	
};
keccak_inc_init_method_spec <- assume MODULE "keccak_inc_init" [] false keccak_inc_init_setup (prover "keccak_inc_init");

// keccak_inc_absorb_setup
// where RATE can be SHAKE128_RATE or SHAKE256_RATE
let keccak_inc_absorb_setup mlen RATE = do {
(stp, st) <- fresh_state "st";
r <- crucible_fresh_var "r" i32;
(mp, m) <- fresh_bytes "m" mlen; 
//crucible_precond {{ st == zero /\ r == (`RATE:[32]) }};
crucible_execute_func [stp, (tm r), mp, (tm {{ `mlen : [64] }})];
res <- crucible_fresh_var "res" state_type;
crucible_points_to stp (tm {{ res }});
//crucible_postcond {{ res == join (transpose (absorb`{w=64} (pad`{r= (RATE*8)} (join [reverse x | x<-m]#0b1111)))) }};
};
keccak_inc_absorb_method_spec <- assume MODULE "keccak_inc_absorb" [KeccakF1600_StatePermute_method_spec] false (keccak_inc_absorb_setup CRHBYTES SHAKE256_RATE) (prover "keccak_inc_absorb");
keccak_inc_absorb_1byte_method_spec <- assume MODULE "keccak_inc_absorb" [KeccakF1600_StatePermute_method_spec] false (keccak_inc_absorb_setup 1 SHAKE256_RATE) (prover "keccak_inc_absorb");

// keccak_inc_squeeze_setup
let keccak_inc_squeeze_setup oplen RATE = do {
    let n = toInt {{ `oplen * `RATE : [32] }};
    (hp, h) <- fresh_bytes "h" n ;
    nblocks <- crucible_fresh_var "nblocks" i64;
    (stp, st) <- fresh_state "st";
    //crucible_precond {{ h == zero /\ s == zero }};
    crucible_execute_func [hp, (tm nblocks), stp, tm {{ `RATE : [32] }}];
    res <- crucible_fresh_var "res" state_type;
    crucible_points_to stp (tm {{ res }});
    //crucible_postcond {{ res == join (transpose(Keccak_f(transpose (split s:[5][5][64])))) }};
    //crucible_postcond {{ zero#(drop`{1} (join (transpose(Keccak_f(transpose (split s:[5][5][64])))))) ==  [join (reverse x) | x<-(groupBy`{8} h)]}};
};
keccak_inc_squeeze_method_spec <- assume MODULE "keccak_inc_squeeze" [KeccakF1600_StatePermute_method_spec] false (keccak_inc_squeeze_setup CRHBYTES SHAKE256_RATE) (prover "keccak_inc_squeeze");

let keccak_inc_finalize_setup RATE = do {
  (stp, st) <- fresh_state "st";
  p <- crucible_fresh_var "p" i8;
  crucible_execute_func [stp, tm {{ `RATE : [32] }}, tm p];
  res <- crucible_fresh_var "res" state_type;
  crucible_points_to stp (tm res);
};
keccak_inc_finalize_method_spec <- assume MODULE "keccak_inc_finalize" [] false (keccak_inc_finalize_setup SHAKE256_RATE) (prover "keccak_inc_finalize");

let shake256_inc_init_setup  = do {
  stp <- alloc_incctx;
  crucible_execute_func[stp];
};
shake256_inc_init_method_spec <- assume MODULE "shake256_inc_init" [keccak_inc_init_method_spec] false shake256_inc_init_setup (prover "shake256_inc_init");     

let shake256_inc_absorb_setup iplen = do {
  stp <- alloc_incctx;
  ip <- alloc_bytes iplen;
  //crucible_precond {{ `iplen == `CRHBYTES }};
  crucible_execute_func [ stp, ip, tm {{ `iplen : [64] }}];
};
shake256_inc_absorb_method_spec <- assume MODULE "shake256_inc_absorb" [keccak_inc_absorb_method_spec] false (shake256_inc_absorb_setup CRHBYTES) (prover "shake256_inc_absorb");     
shake256_inc_absorb_1byte_method_spec <- assume MODULE "shake256_inc_absorb" [keccak_inc_absorb_1byte_method_spec] false (shake256_inc_absorb_setup 1) (prover "shake256_inc_absorb");     
let shake256_inc_squeeze_setup oplen = do {
  stp <- alloc_incctx;
  op <- alloc_bytes oplen;
  //crucible_precond {{ `oplen == `CRYPTO_BYTES }};
  crucible_execute_func [ op, tm {{ `oplen : [64] }}, stp ];
};
shake256_inc_squeeze_method_spec <- assume MODULE "shake256_inc_squeeze" [keccak_inc_squeeze_method_spec] false (shake256_inc_squeeze_setup CRHBYTES) (prover "shake256_inc_squeeze");     

let shake256_inc_finalize_setup = shake256_inc_init_setup;
shake256_inc_finalize_method_spec <- assume MODULE "shake256_inc_finalize" [keccak_inc_finalize_method_spec] false shake256_inc_finalize_setup (prover "shake256_inc_finalize");     
  
    /*let PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_setup = do {
      (st, stp) <- fresh_shake128ctx "st";
      (seed, seedp) <- fresh_bytes "seed" SEEDBYTES;
      nonce <- crucible_fresh_var "nonce" i16;
      crucible_execute_func [stp, seedp,  tm nonce];
    };
    PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init" [] false PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_setup (prover "shake128_stream_init");
*/

 let PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_setup = do {
      ap <- alloc_poly;
      (seedp, seed) <- fresh_bytes "seed" SEEDBYTES;
      nonce <- crucible_fresh_var "nonce" i16;
      crucible_execute_func [ap, seedp, tm nonce];
      //crucible_points_to ap (tm seed);
      assign_fresh_poly ap "a";
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_uniform" [/*PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_method_spec*/] false PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_setup (prover "Poly_uniform");

let PQCLEAN_DILITHIUM2_CLEAN_expand_mat_setup = do {
      matp <- crucible_alloc (llvm_array K (polyvec_type L));
      (rhop, rho) <- fresh_bytes "rho" SEEDBYTES;
      crucible_precond {{ rho != zero }};
      crucible_execute_func [matp, rhop];
      let res = {{ pmToIpm (expandA rho) }};
      crucible_points_to matp (tm res);
      //crucible_postcond {{ pmToIpm res == expandA rho }};
      //crucible_postcond {{ (map (\x -> map (\y -> map (\z -> safe_mod(`Q, z)) y)) x) (ipmToPm res)) == (expandA rho) }};
    };
     // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_expand_mat" [PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_expand_mat_setup (quickcheck 10); // (prover "expand_mat");

    /*
    let PQCLEAN_DILITHIUM2_CLEAN_pack_sig_prefix_setup = do {
      sigp <- alloc_smt_bytes OMEGA_AND_K;
      (hp, h) <- fresh_polyvec "h" K;
      crucible_execute_func [sigp, hp];
      res <- llvm_fresh_cryptol_var "y" {| ByteArray |};
      llvm_points_to_array_prefix sigp res {{ `OMEGA_AND_K : [64] }};
    };
    PQCLEAN_DILITHIUM2_CLEAN_pack_sig_prefix_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_pack_sig_prefix" [] false PQCLEAN_DILITHIUM2_CLEAN_pack_sig_prefix_setup (prover "pack_sig_prefix");
    */

    let PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_setup = do {
      rp <- alloc_bytes POLZ_SIZE_PACKED;
      //rp <- alloc_smt_bytes POLZ_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ polyBound (0 - (`GAMMA1 - 1)) (`GAMMA1 - 1) a }};
      crucible_execute_func [rp, ap];
      let res = {{ polyZPack (ipToP a) }};
      //llvm_points_to_array_prefix rp res {{ `POLZ_SIZE_PACKED : [64] }};
      llvm_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyz_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_setup (prover "Polyz_pack");

    let PQCLEAN_DILITHIUM2_CLEAN_pack_sig_setup = do {
      sigp <- alloc_bytes CRYPTO_BYTES;
      //sigp <- alloc_smt_bytes CRYPTO_BYTES;
      (zp, z) <- fresh_polyvec "z" L;
      (hp, h) <- fresh_polyvec "h" K;
      (cp, c) <- fresh_poly "c";
      crucible_precond {{ and [ and [ polyBound (0 - (`GAMMA1 - 1)) (`GAMMA1 - 1) p | p <- o ] | o <- z ] }};
      crucible_execute_func [sigp, zp, hp, cp];
      let zPV = {{ ipvToPv z }};
      let hPV = {{ ipvToPv h }};
      let cP = {{ ipToP c }};
      let res = {{ split (packSig (zPV, hPV, cP)) : [_][8] }};
      llvm_points_to_array_prefix sigp res {{ `CRYPTO_BYTES : [64] }};
      //crucible_points_to sigp (tm res);
    };
    // Status: hangs while reading the final value from sigp
    PQCLEAN_DILITHIUM2_CLEAN_pack_sig_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_pack_sig" [PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_pack_sig_setup assume_unsat; //(offline_smtlib2 "pack_sig"); //(prover "pack_sig");
                                                     //(prover_with_unints ["PQCLEAN_DILITHIUM2_CLEAN_polyz_pack_method_spec"] "pack_sig"); //(quickcheck 2); //(prover "pack_sig");

    let PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_setup = do {
      a <- crucible_fresh_var "a" i64;
      crucible_precond {{ 0 <=$ a /\ a <=$ `Q * (2^^32) }};
      crucible_execute_func [tm a];
      let res = {{ montgomeryReduce a }};
      crucible_return (tm res);
      crucible_postcond {{ reducedBound res }};
      crucible_postcond {{ safe_product (res, `M) % `Q == safe_mod(`Q, a) }};
    };
    // Status: succeeds (quick check succeeds with the full postcondition and proof succeeds only with the first post condition and goes for ever for the full post condition)
    PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce" [] false PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_setup (prover "montgomeryReduce"); //(quickcheck 1000);

     let PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ reducedBoundPoly a }};
      crucible_execute_func [ap];
      let res = {{ nttInvImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ reducedBoundPoly res }};

    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont" [PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_setup (do {
        print_goal_consts;
        assume_unsat;
    });
    
     let PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ reducedBoundPoly a }};
      crucible_execute_func [ap];
      let res = {{ nttInvImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ reducedBoundPoly res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery" [PQCLEAN_DILITHIUM2_CLEAN_invntt_frominvmont_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_setup (unint_yices ["nttInvImp"]);

    let PQCLEAN_DILITHIUM2_CLEAN_ntt_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      let res = {{ nttImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ polyBound 0 (16 * `Q) res }};
    };
    // Status: runs forever but quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_ntt_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_ntt" [PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_ntt_setup (do {
        print_goal_consts;
        assume_unsat;
    });
    
  let PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      let res = {{ nttImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ polyBound 0 (16 * `Q) res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_ntt" [PQCLEAN_DILITHIUM2_CLEAN_ntt_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_setup (unint_yices ["nttImp"]);

  let PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_setup = do {
      cp <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      //crucible_precond {{ (polyBound 0 (22 * `Q) a) /\  (polyBound 0 (22 *` Q) b)}};
      crucible_precond {{ (polyBound 0 (22 * `Q) a) /\ (polyBoundGEq 0 (22 * `Q) b) }};
      crucible_execute_func [cp, ap, bp];
      let res = {{ nttPolyMultImp a b }};
      crucible_points_to cp (tm res);
      //crucible_postcond {{ polyBound 0 (2 * `Q) res }};
    };
    // Status: quickcheck passes but generates 257 substantial goals to prove preconditions of montgomeryReduce
    PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery" [PQCLEAN_DILITHIUM2_CLEAN_montgomery_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_setup (unint_prover "poly_point_inv" ["montgomeryReduce"]);

    let PQCLEAN_DILITHIUM2_CLEAN_reduce32_setup = do {
      a <- crucible_fresh_var "a" i32;
      crucible_execute_func [tm a];
      let res = {{ reduce32 a }};
      crucible_return (tm res);
      crucible_postcond {{ reducedBound res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_reduce32_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_reduce32" [] false PQCLEAN_DILITHIUM2_CLEAN_reduce32_setup (prover "reduce32");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      let res = {{ polyReduceImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ reducedBoundPoly res }}; 
    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_reduce" [PQCLEAN_DILITHIUM2_CLEAN_reduce32_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_setup (prover "Poly_reduce");

 let PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_setup = do {
      arg0_star <- crucible_fresh_var "arg0" (llvm_type "%struct.shake128ctx");
      arg0 <- crucible_alloc (llvm_type "%struct.shake128ctx");
      crucible_points_to arg0 (tm arg0_star);
      arg1_star <- crucible_fresh_var "arg1" i8;
      arg1 <- crucible_alloc i8;
      crucible_points_to arg1 (tm arg1_star);
      arg2 <- crucible_fresh_var "arg2" i16;
      crucible_execute_func [arg0, arg1, tm arg2];
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init" [] false PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_setup (prover "shake256_stream_init");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_setup = do {
      ap <- alloc_polyvec L;
      (seedp, seed) <- fresh_bytes "seed" CRHBYTES;
      nonce <- crucible_fresh_var "nonce" i16;
      crucible_execute_func [ap, seedp, tm nonce];
      crucible_points_to ap (tm {{ pvToIpv (expandMask (seed, nonce)) }});
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1" [PQCLEAN_DILITHIUM2_CLEAN_shake256_stream_init_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_setup (prover "Poly_uniform_gamma1m1");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup = do {
      cp <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      crucible_execute_func [cp, ap, bp];
      crucible_points_to ap (tm a);
      crucible_points_to bp (tm b);
      let res = {{ polyAddImp a b }};
      crucible_points_to cp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_add" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup (prover "Poly_add");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup2 = do {
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      crucible_execute_func [ap, ap, bp];
      crucible_points_to bp (tm b);
      crucible_points_to ap (tm {{ polyAddImp a b }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec2 <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_add" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_add_setup2 (prover "Poly_add");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_setup = do {
      wp <-  alloc_polyvec K;
      (up, u) <- fresh_polyvec "u" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_execute_func [wp, up, vp];
      crucible_points_to wp (tm {{ polyVecAddImp u v }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_add" [PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_setup (unint_prover "Polyveck_add" ["polyAddImp"]);

    let PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_setup = do {
      (ap, a) <- fresh_poly "a";
      b <- crucible_fresh_var "b" i32;
      crucible_precond {{ standardPoly a }};
      crucible_precond {{ b <= `GAMMA1 - `BETA }};// \/ b == `GAMMA2 - `BETA }};
      crucible_execute_func [ap, tm b];
      //let res = {{ zero # (infNormPoly (ipToP a)) : [32] }};
      //crucible_return (tm {{ if res < b then (zero:[32]) else (1:[32]) }});
      let res = {{ polyChkNorm (ipToP a) (drop b) }};
      crucible_return (tm {{ (zero # [res]) : [32] }});
    };
    // Status: quickcheck passes
    PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_setup (quickcheck 10);// (prover "Poly_chknorm");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      b <- crucible_fresh_var "b" i32;
      crucible_precond {{ standardPolyVec a }};
      crucible_precond {{ b <= `GAMMA1 - `BETA }};
      crucible_execute_func [ap, tm b];
      //let res = {{ zero # (infNormPolyVec (ipvToPv a)) : [32] }};
      //crucible_return (tm {{ zero # [res < b] : [32] }});
      let res = {{ polyVecChkNorm (ipvToPv a) (drop b) }};
      crucible_return (tm {{ (zero # [res]) : [32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm" [PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_setup (prover "Polyveck_chknorm");

    let PQCLEAN_DILITHIUM2_CLEAN_csubq_setup = do {
      a <- crucible_fresh_var "a" i32;
      crucible_execute_func [tm a];
      let res = {{ csubq a }};
      crucible_return (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_csubq_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_csubq" [] false PQCLEAN_DILITHIUM2_CLEAN_csubq_setup (prover "csubq");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyCsubqImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_csubq" [PQCLEAN_DILITHIUM2_CLEAN_csubq_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_setup (prover "Poly_csubq");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyVecCsubqImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq" [PQCLEAN_DILITHIUM2_CLEAN_poly_csubq_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_setup (prover "Polyveckcsubq");

    let PQCLEAN_DILITHIUM2_CLEAN_decompose_setup = do {
      a <- crucible_fresh_var "a" i32;
      a1p <- crucible_alloc i32;
      crucible_precond {{ standard a }};
      crucible_execute_func [tm a, a1p];
      let res = {{ decompose (drop a) }}; // (high_bits, low_bits)
      let highBits = {{ sext (res.0) : [32] }}; // high_bits
      let lowBits = {{ sext (res.1) : [32] }}; // low_bits
      crucible_points_to a1p (tm lowBits);
      crucible_return (tm highBits); 
      crucible_postcond {{ decomposePc res.1 res.0 (drop a) }};
    };
    // Status: counterexample in points_to and postcond
    PQCLEAN_DILITHIUM2_CLEAN_decompose_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_decompose" [] false PQCLEAN_DILITHIUM2_CLEAN_decompose_setup (prover "decompose");
    
   let PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_setup = do {
      (a0p, a0) <- fresh_poly "a0";
      (a1p, a1) <- fresh_poly "a1";
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standardPoly a }};
      crucible_execute_func [a1p, a0p, ap];
      let res = {{ decomposePoly (ipToP a) }};
      crucible_points_to a0p (tm {{ pToIP (res.1) }});
      crucible_points_to a1p (tm {{ pToIP (res.0) }});
      crucible_postcond {{ decomposePolyPc res.1 res.0 (ipToP a) }};
   };
    // Status: succeeds 
    PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_decompose" [PQCLEAN_DILITHIUM2_CLEAN_decompose_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_setup (unint_prover "Poly_decompose" ["decompose", "decomposePc"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_setup = do {
      (v0p, v0) <- fresh_polyvec "v0" K;
      (v1p, v1) <- fresh_polyvec "v1" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ standardPolyVec v }};
      crucible_execute_func [v0p, v1p, vp];
      let res = {{ decomposePolyVec (ipvToPv v) }};
      crucible_points_to v0p (tm {{ pvToIpv (res.0) }});
      crucible_points_to v1p (tm {{ pvToIpv (res.1) }});
      crucible_postcond {{ decomposePolyVecPc res.1 res.0 (ipvToPv v) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose" [PQCLEAN_DILITHIUM2_CLEAN_poly_decompose_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_setup (unint_prover "Polyveck_decompose" ["decomposePoly", "decomposePolyPc"]);

  let PQCLEAN_DILITHIUM2_CLEAN_freeze_setup = do {
      a <- crucible_fresh_var "a" i32;
      crucible_execute_func [tm a];
      let res = {{ freeze a }};
      crucible_return (tm res);
      crucible_postcond {{ standard res }};
      crucible_postcond {{ res == safe_mod(`Q, a) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_freeze_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_freeze" [PQCLEAN_DILITHIUM2_CLEAN_reduce32_method_spec, PQCLEAN_DILITHIUM2_CLEAN_csubq_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_freeze_setup (unint_prover "freeze" [/*"csubq", "reduce32"*/]);

    let PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      let res = {{ polyFreezeImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ standardPoly res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_freeze" [PQCLEAN_DILITHIUM2_CLEAN_freeze_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_setup (unint_prover "Poly_freeze" ["freeze"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_execute_func [ap];
      let res = {{ polyVecFreezeImp a }};
      crucible_points_to ap (tm res);
      crucible_postcond {{ standardPolyVec res }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze" [PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_setup (unint_prover "Polyveck_freeze" ["polyFreezeImp"]);

    let PQCLEAN_DILITHIUM2_CLEAN_make_hint_setup = do {
      arg0 <- crucible_fresh_var "arg0" i32;
      arg1 <- crucible_fresh_var "arg1" i32;
      crucible_precond {{ standard arg0 }};
      crucible_precond {{ standard arg1 }};
      crucible_execute_func [tm arg0, tm arg1];
      let res = {{ makeHintNew (drop arg0, drop arg1) }};
      crucible_return (tm {{ zext [res]:[32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_make_hint_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_make_hint" [] false PQCLEAN_DILITHIUM2_CLEAN_make_hint_setup (prover "make_hint");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_setup = do {
      hp <- alloc_poly;
      (a0p, a0) <- fresh_poly "a0";
      (a1p, a1) <- fresh_poly "a1";
      crucible_precond {{ standardPoly a0 /\ standardPoly a1 }};
      crucible_execute_func [hp, a0p, a1p];
      crucible_return (tm {{ zext (makeHintPolyNew (ipToP a0, ipToP a1)) : [32] }});
    };
    // Status: succeeds
    // NB: slow to verify
    PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_method_spec <- slow_verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint" [PQCLEAN_DILITHIUM2_CLEAN_make_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_setup (prover "poly_make_hint");//(unint_prover "Poly_make_hint" ["makeHintNew"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_setup = do {
      hp <- alloc_polyvec K;
      (v0p, v0) <- fresh_polyvec "v0" K;
      (v1p, v1) <- fresh_polyvec "v1" K;
      crucible_precond {{ standardPolyVec v0 /\ standardPolyVec v1 }};
      crucible_execute_func [hp, v0p, v1p];
      crucible_return (tm {{ zext (makeHintPolyVecNew (ipvToPv v0, ipvToPv v1)) : [32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint" [PQCLEAN_DILITHIUM2_CLEAN_poly_make_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_setup (prover "polyveck_make_hint"); //(unint_prover "Polyveck_make_hint" ["makeHintPolyNew"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_setup = do {
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ standardPolyVec v }};
      crucible_execute_func [vp];
      let res = {{ nttVecImp v }};
      crucible_points_to vp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt" [PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_setup (unint_yices ["nttImp"]);
    
    let PQCLEAN_DILITHIUM2_CLEAN_poly_sub_setup = do {
      cp <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      (bp, b) <- fresh_poly "b";
      crucible_precond {{ reducedBoundPoly b }}; // TODO: may not be necessary
      crucible_execute_func [cp, ap, bp];
      crucible_points_to ap (tm a);
      crucible_points_to bp (tm b);
      crucible_points_to cp (tm {{ polySubImp a b }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_sub_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_sub" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_sub_setup (prover "Poly_sub");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_setup = do {
      wp <- alloc_polyvec K;
      (up, u) <- fresh_polyvec "u" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ reducedBoundPolyVec u /\ reducedBoundPolyVec v }};
      crucible_execute_func [wp, up, vp];
      crucible_points_to wp (tm {{ polyVecSubImp u v }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub" [PQCLEAN_DILITHIUM2_CLEAN_poly_sub_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_setup (prover "Polyveck_sub");

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_setup = do {
      wp <- alloc_polyvec L;
      (up, u) <- fresh_polyvec "u" L;
      (vp, v) <- fresh_polyvec "v" L;
      crucible_execute_func [wp, up, vp];
      crucible_points_to wp (tm {{ polyVecAddImp u v }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add" [PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_setup (prover "Polyvecl_add");

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_setup = do {
      (ap, a) <- fresh_polyvec "a" L;
      b <- crucible_fresh_var "b" i32;
      crucible_precond {{ standardPolyVec a }};
      //crucible_precond {{ standard b }};
      crucible_execute_func [ap, tm b];
      let res = {{ zero # (infNormPolyVec (ipvToPv a)) : [32] }};
      crucible_return (tm {{ zero # [res < b] : [32] }});
    };
    // Status: counterexample
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm" [PQCLEAN_DILITHIUM2_CLEAN_poly_chknorm_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_setup (unint_prover "Polyvecl_chknorm" ["infNormPoly"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_setup = do {
      (vp, v) <- fresh_polyvec "v" L;
      crucible_execute_func [vp];
      crucible_points_to vp (tm {{ polyVecFreezeImp v}});
    };
    // Status: succeeds
    // NB: slow to verify
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze" [PQCLEAN_DILITHIUM2_CLEAN_poly_freeze_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_setup (unint_prover "Polyvecl_freeze" ["polyFreezeImp"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_setup = do {
      (vp, v) <- fresh_polyvec "v" L;
      crucible_precond {{ standardPolyVec v }};
      crucible_execute_func [vp];
      crucible_points_to vp (tm {{ nttVecImp v }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt" [PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_setup (unint_yices ["nttImp"]);
    
    let PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_setup = do {
      wp <- alloc_poly;
      (up, u) <- fresh_polyvec "u" K;
      (vp, v) <- fresh_polyvec "v" K;
      crucible_precond {{ (polyVecBound 0 (22 * `Q) u) /\ (polyVecBoundGEq 0 (22 * `Q) v) }};
      crucible_execute_func [wp, up, vp];
      //crucible_points_to wp (tm {{ nttDotProductImp u v }});
    };
    // Status: succeeds
    // NB: slow to verify
    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec <- slow_verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery" [PQCLEAN_DILITHIUM2_CLEAN_poly_add_method_spec2, PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_setup (unint_yices ["nttPolyMultImp"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_setup = do {
      rp <- alloc_poly;
      (ap, a) <- fresh_bytes "a" POLETA_SIZE_PACKED ;
      crucible_precond {{ and [ (byteBound (-`ETA) (`ETA) x) | x <- a ] }};
      crucible_execute_func [rp, ap];
      let res = {{ unpackPolyEta a }};
      crucible_points_to rp (tm {{ pToIP res }});
      crucible_postcond {{ polyBound (`Q - `ETA) (`Q + `ETA) (pToIP res) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_setup (prover "Polyeta_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_setup = do {
      rp <- alloc_poly;
      (ap, a) <- fresh_bytes "a" POLT0_SIZE_PACKED;
      crucible_precond {{ and [ -2^^(`D-1) <$ c /\ c <=$ 2^^(`D-1) | c <- a ] }};
      crucible_execute_func [rp, ap];
      let res = {{ (polyT0Unpack a) }};
      crucible_points_to rp (tm {{ pToIP res }});
      crucible_postcond {{ polyBoundLEq (`Q - (2^^(`D - 1))) (`Q + (2^^(`D - 1))) (pToIP res) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_setup (prover "Polyt0_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_setup = do {
      rhop <- alloc_bytes SEEDBYTES;
      keyp <- alloc_bytes SEEDBYTES;
      trp <- alloc_bytes CRHBYTES;
      s1p <- alloc_polyvec L;
      s2p <- alloc_polyvec K;
      t0p <- alloc_polyvec K;
      (skp, sk) <- fresh_bytes "sk" CRYPTO_SECRETKEYBYTES; 
      let Idx = toInt {{ 2 * `SEEDBYTES + ` CRHBYTES : [32] }};
      crucible_precond {{ and [ byteBound (-`ETA) (`ETA) x | x <- sk@@[Idx..1007] ] }};
      crucible_precond {{ and [ -2^^(`D-1) <$ c /\ c <=$ 2^^(`D-1) | c <- sk@@[1008..CRYPTO_SECRETKEYBYTES - 1] ] }};
      crucible_execute_func [rhop, keyp, trp, s1p, s2p, t0p, skp];
      let res = {{ unpackSk sk }};
      crucible_points_to rhop (tm {{ res.0 }});
      crucible_points_to keyp (tm {{ res.1 }});
      crucible_points_to trp (tm {{ res.2 }});
      crucible_points_to s1p (tm {{ pvToIpv res.3 }});
      crucible_points_to s2p (tm {{ pvToIpv res.4 }});
      crucible_points_to t0p (tm {{ pvToIpv res.5 }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_method_spec <- slow_verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_unpack_sk" [PQCLEAN_DILITHIUM2_CLEAN_polyeta_unpack_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyt0_unpack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_setup (prover "unpackSk");

    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_setup mlen = do {
      let siglen = CRYPTO_BYTES;
      sigp <- alloc_bytes siglen;
      siglenp <- crucible_alloc i64;
      (mp, m) <- fresh_bytes "m" mlen;
      (skp, sk) <- fresh_bytes "sk" CRYPTO_SECRETKEYBYTES;
      //crucible_precond {{ `mlen == `CRHBYTES }};
      let Idx = toInt {{ 2 * `SEEDBYTES + ` CRHBYTES : [32] }};
      crucible_precond {{ and [ byteBound (-`ETA) (`ETA) x | x <- sk@@[Idx..1007] ] }};
      crucible_precond {{ and [ -2^^(`D-1) <$ c /\ c <=$ 2^^(`D-1) | c <- sk@@[1008..CRYPTO_SECRETKEYBYTES - 1] ] }};
      crucible_execute_func [sigp, siglenp, mp, tm {{ `mlen : [64] }}, skp];
      let sk_rec = {{ skTupleToRec (unpackSk sk) }};
      let sig = {{ split (packSig (sign`{mlen} sk_rec (join m))): [siglen][8] }};
      crucible_points_to sigp (tm sig);
      len <- crucible_fresh_var "len" i64;
      crucible_points_to siglenp (tm len);
      crucible_postcond {{ len == `CRYPTO_BYTES }};
      crucible_points_to mp (tm m);
      crucible_points_to skp (tm sk);
      crucible_return (tm {{ 0 : [32] }});
    };
    // Status: hangs applying override for poly_uniform_gamma1m1 (or right after it?)
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature" 
                                                                  [ PQCLEAN_DILITHIUM2_CLEAN_challenge_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_pack_sig_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_gamma1m1_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_chknorm_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_decompose_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_method_spec, 
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_make_hint_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_add_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_freeze_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec,
                                                                    PQCLEAN_DILITHIUM2_CLEAN_unpack_sk_method_spec,
                                                                    shake256_inc_init_method_spec,
                                                                    shake256_inc_squeeze_method_spec,
                                                                    shake256_inc_absorb_method_spec,
                                                                    shake256_inc_absorb_1byte_method_spec,
                                                                    shake256_inc_finalize_method_spec
                                                                  ] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_setup 1) (prover "crypto_sign_signature");

    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_setup mlen = do {
      let smlen = toInt {{ `CRYPTO_BYTES + `mlen : [64] }};
      smp <- alloc_bytes smlen;
      smlenp <- crucible_alloc i64;
      (mp, m) <- fresh_bytes "m" mlen;
      (skp, sk) <- fresh_bytes "sk" CRYPTO_SECRETKEYBYTES;
      let Idx = toInt {{ 2 * `SEEDBYTES + ` CRHBYTES : [32] }};
      crucible_precond {{ `mlen >= 1 }};
      crucible_precond {{ and [ byteBound (-`ETA) (`ETA) x | x <- sk@@[Idx..1007] ] }};
      crucible_precond {{ and [ -2^^(`D-1) <$ c /\ c <=$ 2^^(`D-1) | c <- sk@@[1008..CRYPTO_SECRETKEYBYTES - 1] ] }};
      crucible_execute_func [smp, smlenp, mp, tm {{ `mlen : [64] }}, skp];
      let sk_rec = {{ skTupleToRec (unpackSk sk) }};
      let sm = {{ split (cryptoSign sk_rec (join m)) : [smlen][8] }};
      crucible_points_to smp (tm sm);
      len <- crucible_fresh_var "len" i64;
      crucible_points_to smlenp (tm len);
      crucible_postcond {{ len == `smlen }};
      crucible_points_to mp (tm m);
      crucible_points_to skp (tm sk);
      crucible_return (tm {{ 0 : [32] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign" [PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_signature_method_spec] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_setup 1) (prover "crypto_sign");

    let PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_setup = do {
      rp <- alloc_bytes POLT1_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      // the input coefficients are in { 0,..., 2^^9-1 }
      crucible_precond {{ polyBoundGEq 0 512 a }};
      crucible_execute_func [rp, ap];
      crucible_points_to rp (tm {{ split (polyT1Pack (ipToP a)):[_][8] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_setup (prover "Polyt1_pack");

    let PQCLEAN_DILITHIUM2_CLEAN_pack_pk_setup = do {
      pkp <- alloc_bytes CRYPTO_PUBLICKEYBYTES;
      (rhop, rho) <- fresh_bytes "rho" SEEDBYTES;
      (t1p, t1) <- fresh_polyvec "t1" K;
      crucible_precond {{ standardPolyVec t1 }};
      crucible_precond {{ polyVecBoundGEq 0 512 t1 }};
      crucible_execute_func [pkp, rhop, t1p];
      crucible_points_to pkp (crucible_term {{ packPkImp rho t1 }});

    };
    // Status: succeeds
    // assuming it for now to speed up proving other functions
    PQCLEAN_DILITHIUM2_CLEAN_pack_pk_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_pack_pk" [PQCLEAN_DILITHIUM2_CLEAN_polyt1_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_pack_pk_setup (prover "packPk");

    let PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_setup = do {
      rp <- alloc_bytes POLETA_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ polyBound (`Q - `ETA) (`Q + `ETA) a }};
      crucible_execute_func [rp, ap];
      let res = {{ packPolyEtaImp a }};
      crucible_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_setup (prover "Polyeta_pack");

    let PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_setup = do {
      rp <- alloc_bytes POLT0_SIZE_PACKED;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ polyBoundLEq (0 - (2^^(`D - 1))) (2^^(`D - 1)) a }};
      crucible_execute_func [rp, ap];
      let res = {{ split (polyT0Pack (ipToP a)):[_][8] }};
      crucible_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_setup (prover "Polyt0_pack");

  let PQCLEAN_DILITHIUM2_CLEAN_pack_sk_setup = do {
      skp <- alloc_bytes CRYPTO_SECRETKEYBYTES; 
      (rhop, rho) <- fresh_bytes "rho" SEEDBYTES;
      (keyp, key) <- fresh_bytes "key" SEEDBYTES;
      (trp, tr) <- fresh_bytes "tr" CRHBYTES;
      (s1p, s1) <- fresh_polyvec "s1" L;
      (s2p, s2) <- fresh_polyvec "s2" K;
      (t0p, t0) <- fresh_polyvec "t0" K;
      crucible_precond {{ polyVecBound (`Q - `ETA) (`Q + `ETA) s1 }};
      crucible_precond {{ polyVecBound (`Q - `ETA) (`Q + `ETA) s2 }};
      crucible_precond {{ polyVecBoundLEq (0 - (2^^(`D - 1))) (2^^(`D - 1)) t0 }};
      crucible_execute_func [skp, rhop, keyp, trp, s1p, s2p, t0p];
      let res = {{ split (packSk rho key tr (ipvToPv s1) (ipvToPv s2) (ipvToPv t0)) :[_][8] }};
      crucible_points_to skp (tm res);
    };
    // Status: succeeds
    // NB: slow to verify
    PQCLEAN_DILITHIUM2_CLEAN_pack_sk_method_spec <- slow_verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_pack_sk" [PQCLEAN_DILITHIUM2_CLEAN_polyeta_pack_method_spec, PQCLEAN_DILITHIUM2_CLEAN_polyt0_pack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_pack_sk_setup (prover "pack_sk");
    let PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_setup = do {
      (ap, a) <- fresh_poly "a";
      (seedp, seed) <- fresh_bytes "seed" SEEDBYTES;
      nonce <- crucible_fresh_var "nonce" i16;
      crucible_execute_func [ap, seedp, tm nonce];
      //(_, res) <- fresh_poly "res";
      //crucible_points_to ap (tm res);
      crucible_points_to ap (tm {{ pToIP (polyUniformEta seed nonce)}});
      //assign_fresh_poly ap "a";
    };
    // NB: we aren't going to verify this function
    PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta" [/*PQCLEAN_DILITHIUM2_CLEAN_shake128_stream_init_method_spec*/] false PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_setup (prover "Poly_uniform_eta");

    let PQCLEAN_DILITHIUM2_CLEAN_power2round_setup = do {
      a <- crucible_fresh_var "a" i32;
      a0p <- crucible_alloc i32;
      crucible_precond {{ standard a }};
      crucible_execute_func [tm a, a0p];
      let res = {{ power2Round (drop a) }};
      let a0 = {{ sext (res.1) : [32] }};
      let a1 = {{ sext (res.0) : [32] }};
      crucible_points_to a0p (tm {{ `Q + a0 }});
      crucible_return (tm {{ a1 }});
      crucible_postcond {{ a % `Q == a1*(2^^`D) + a0 }};
      crucible_postcond {{ (0 - 2)^^(`D - 1) <$ a0 }};
      crucible_postcond {{ a0 <=$ 2^^(`D - 1) }};
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_power2round_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_power2round" [] false PQCLEAN_DILITHIUM2_CLEAN_power2round_setup (prover "power2round");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_setup = do {
      a1p <- alloc_poly;
      a0p <- alloc_poly;
      (ap, a) <- fresh_poly "a";
      crucible_precond {{ standardPoly a }};
      crucible_execute_func [a1p, a0p, ap];
      let res = {{ polyPower2Round (ipToP a) }};
      crucible_points_to a0p (tm {{ addQToPoly (res.1) }});
      crucible_points_to a1p (tm {{ pToIP (res.0) }});
    };
    // Status: succeeds
    // NB: slow to verify
    PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_method_spec <- slow_verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_power2round" [PQCLEAN_DILITHIUM2_CLEAN_power2round_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_setup (unint_prover "Poly_power2round" ["power2Round"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_setup = do {
      a0p <- alloc_polyvec K;
      a1p <- alloc_polyvec K;
      (ap, a) <- fresh_polyvec "a" K;
      crucible_precond {{ standardPolyVec a }};
      crucible_execute_func [a1p, a0p, ap];
      let res = {{ power2RoundPolyVec (ipvToPv a) }};
      crucible_points_to a0p (tm {{ addQToPolyVec (res.1) }});
      crucible_points_to a1p (tm {{ pvToIpv (res.0) }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round" [PQCLEAN_DILITHIUM2_CLEAN_poly_power2round_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_setup (unint_prover "Polyveck_power2round" ["polyPower2Round"]);
    
    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair_setup = do {
      pkp <- alloc_bytes CRYPTO_PUBLICKEYBYTES;
      skp <- alloc_bytes 2800; //CRYPTO_SECRETKEYBYTES;
      let sbytes = toInt {{ 3 * `SEEDBYTES : [8] }};
      (seedp, seed) <- fresh_bytes "seed" sbytes;
      crucible_execute_func [pkp, skp];
      let res = {{ gen (join seed) }};
      let pk = {{ res.0 }};
      let sk = {{ res.1 }};
      let pk = {{ packPk (split pk.rho) pk.t1 }};
      let sk = {{ packSk (split sk.rho) (split sk.key) (split sk.tr) sk.s1 sk.s2 sk.t0 }};
      //pk <- crucible_fresh_var "pk" (llvm_array CRYPTO_PUBLICKEYBYTES i8);
      //sk <- crucible_fresh_var "pk" (llvm_array CRYPTO_SECRETKEYBYTES i8);
      crucible_points_to pkp (tm {{ split pk : [_][8] }});
      crucible_points_to skp (tm {{ split sk : [_][8] }});
      crucible_return (tm {{ 0 : [32] }});
    };
    // NB: we aren't going to verify this function as it uses random seed.
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair_method_spec <- assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair" [ PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec, 
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_pack_pk_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_pack_sk_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_poly_uniform_eta_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyveck_add_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyveck_freeze_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyveck_power2round_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec,
                                                                                                                                PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec,
                                                                                                                                randombytes_method_spec 
                                                                                                                              ] false PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_keypair_setup (prover "keypair");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_precond {{ reducedBoundPolyVec a }};
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ nttInvVecImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery" [PQCLEAN_DILITHIUM2_CLEAN_poly_invntt_montgomery_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_setup (unint_prover "Polyveck_invntt_montgomery" ["nttInvImp"]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyVecReduceImp a }});
      //crucible_postcond {{ reducedBoundPolyVec a }}; // TODO: doesn't work right now?
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce" [PQCLEAN_DILITHIUM2_CLEAN_poly_reduce_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_setup (unint_prover "Polyveck_reduce" ["polyReduceImp"]);

    let PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_setup = do {
      (ap, a) <- fresh_poly "a";
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ polyShiftlImp a }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl" [] false PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_setup (prover "Poly_shiftl");

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_setup = do {
      (ap, a) <- fresh_polyvec "a" K;
      crucible_execute_func [ap];
      crucible_points_to ap (tm {{ [polyVecShiftlImp (a@0)] }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl" [PQCLEAN_DILITHIUM2_CLEAN_poly_shiftl_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_setup (prover "Polyveck_shiftl");

    let PQCLEAN_DILITHIUM2_CLEAN_use_hint_setup = do {
      arg0 <- crucible_fresh_var "arg0" i32;
      arg1 <- crucible_fresh_var "arg1" i32;
      crucible_precond {{ standard arg0  }};
      crucible_precond {{ bitCoeff arg1 }};
      crucible_execute_func [tm arg0, tm arg1];
      crucible_return (tm {{ zext (useHint (drop arg0, drop arg1)):[32]}});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_use_hint_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_use_hint" [PQCLEAN_DILITHIUM2_CLEAN_decompose_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_use_hint_setup (prover "use_hint");

    let PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_setup = do {
      ap <- alloc_poly;
      (bp, b) <- fresh_poly "b";
      (hp, h) <- fresh_poly "h";
      crucible_precond {{ standardPoly b }};
      crucible_precond {{ bitCoeffPoly h }};
      crucible_execute_func [ap, bp, hp];
      crucible_points_to ap (tm {{ pToIP (useHintPoly (ipToP b) (ipToP h)) }});
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint" [PQCLEAN_DILITHIUM2_CLEAN_use_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_setup (unint_prover "Poly_use_hint" [/*"useHint"*/]);

    let PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_setup = do {
      wp <- alloc_polyvec K;
      (up, u) <- fresh_polyvec "u" K;
      (hp, h) <- fresh_polyvec "h" K;
      crucible_precond {{ standardPolyVec u }}; 
      crucible_precond {{ bitCoeffPolyVec h }}; 
      crucible_execute_func [wp, up, hp]; 
      crucible_points_to wp (tm {{pvToIpv (useHintPolyVec (ipvToPv u, ipvToPv h))}});
    };
    // Status: hangs in Yices
    PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint" [PQCLEAN_DILITHIUM2_CLEAN_poly_use_hint_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_setup (unint_prover "Polyveck_use_hint" ["useHintPoly"]);
    
    let PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_setup = do {
      rp <- alloc_poly;
      (ap, a) <- fresh_bytes "a" POLT1_SIZE_PACKED; 
      crucible_precond{{ standardBytes a }};
      crucible_execute_func [rp, ap];
      let res = {{ pToIP (polyT1Unpack a) }};
      crucible_points_to rp (tm res);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_method_spec <- verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_setup (prover "Polyt1_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_setup = do {
      rhop <- alloc_bytes SEEDBYTES;
      t1p <- alloc_polyvec K;
      (pkp, pk) <- fresh_bytes "pk" CRYPTO_PUBLICKEYBYTES;
      crucible_precond {{ standardBytes (drop`{SEEDBYTES} pk) }};
      crucible_execute_func [rhop, t1p, pkp];
      let rho = {{ (unpackPk pk).0 }};
      let t1 = {{ pvToIpv (unpackPk pk).1 }};
      crucible_points_to rhop (tm rho);
      crucible_points_to t1p (tm t1);
    };
    // Status: succeeds
    PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_method_spec <- slow_verify MODULE "PQCLEAN_DILITHIUM2_CLEAN_unpack_pk" [PQCLEAN_DILITHIUM2_CLEAN_polyt1_unpack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_setup (prover "unpackPk");

    let PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_setup = do {
      rp <-  alloc_poly; 
      (ap, a) <- fresh_bytes "a" POLZ_SIZE_PACKED;
      crucible_precond {{ standardBytes a }};
      crucible_execute_func [rp, ap];
      let res = {{ pToIP (polyZUnpack a) }};
      crucible_points_to rp (tm res);
    };
    // Status: counterexample
    PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack" [] false PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_setup (prover "Polyz_unpack");
    
    let PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_setup = do {
      zp <- alloc_polyvec L;
      hp <- alloc_polyvec K;
      cp <- alloc_poly;
      (sigp, sig) <- fresh_bytes "sig" CRYPTO_BYTES;
      //crucible_precond {{ standardBytes (sig@@[0..(L - 1) * POLZ_SIZE_PACKED - 1]) }};
      crucible_execute_func [ zp, hp, cp, sigp ];
      let res = {{ unpackSig sig }};
      let z = {{ pvToIpv res.0 }};
      let h = {{ pvToIpv res.1 }};
      let c = {{ pToIP   res.2 }};
      crucible_points_to zp (tm z);
      crucible_points_to hp (tm h);
      crucible_points_to cp (tm c);
      crucible_postcond {{ standardPolyVec z }};
      crucible_postcond {{ standardPolyVec h }};
      crucible_postcond {{ standardPoly c }};
      crucible_return (tm {{ 0 : [32] }});
    };
    // Status: applies override and symbolic simulation completes successfully but then hangs on even with an overnight run
    PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_unpack_sig" [PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_method_spec] false PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_setup  (prover "unpack_sig"); //(assume_unsat); //(prover "unpack_sig");
                                                     //(prover_with_unints ["PQCLEAN_DILITHIUM2_CLEAN_polyz_unpack_method_spec"] "unpack_sig");
    
     let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_setup mlen = do {
      let siglen = CRYPTO_BYTES;
      (sigp, sig) <- fresh_bytes "sig" siglen;
      (mp, m) <- fresh_bytes "m" mlen;
      (pkp, pk) <- fresh_bytes "pk" CRYPTO_PUBLICKEYBYTES;
      crucible_precond {{ standardBytes (drop`{SEEDBYTES} pk) /\ standardBytes (sig@@[0..(L - 1) * POLZ_SIZE_PACKED - 1]) }};
      crucible_execute_func [sigp, tm {{ `siglen : [64] }}, mp, tm {{ `mlen : [64] }}, pkp];
      let res = {{ verify (pkBytesToRec pk) (join m) (unpackSig sig) }};
      crucible_return (tm {{ if res then zero else ~zero : [32] }});
    };
    // Status: simulates but generates a counterexample for a memory load
    // need override for crh
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify"
      [ PQCLEAN_DILITHIUM2_CLEAN_challenge_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_expand_mat_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_poly_ntt_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_poly_pointwise_invmontgomery_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyveck_csubq_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyveck_invntt_montgomery_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyveck_ntt_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyveck_reduce_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyveck_shiftl_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyveck_sub_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyveck_use_hint_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyvecl_chknorm_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyvecl_ntt_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_polyvecl_pointwise_acc_invmontgomery_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_unpack_pk_method_spec
      , PQCLEAN_DILITHIUM2_CLEAN_unpack_sig_method_spec
      , shake256_inc_init_method_spec
      , shake256_inc_squeeze_method_spec
      , shake256_inc_absorb_method_spec
      , shake256_inc_finalize_method_spec] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_setup 1) (prover "crypto_sign_verify");

    let PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open_setup mlen = do {
      let smlen = toInt {{ `CRYPTO_BYTES + `mlen : [64] }}; 
      mp <- alloc_bytes mlen;
      mlenp <- crucible_alloc i64;
      (smp, sm) <- fresh_bytes "sm" smlen;
      (pkp, pk) <- fresh_bytes "pk" CRYPTO_PUBLICKEYBYTES;
      crucible_precond {{ standardBytes (drop`{SEEDBYTES} pk) /\ standardBytes (sm@@[0..(L - 1) * POLZ_SIZE_PACKED - 1]) }};
      crucible_execute_func [mp, mlenp, smp, (tm {{ `smlen : [64] }}), pkp];
      let res = {{ open (pkBytesToRec pk) sm }};
      crucible_return (tm {{ if res then zero else ~zero : [32] }});
    };
    // Status: simulates but takes forever checking VCs even with no return spec
    PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open_method_spec <- temp_assume MODULE "PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open" [PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_verify_method_spec] false (PQCLEAN_DILITHIUM2_CLEAN_crypto_sign_open_setup 1) (prover "crypto_sign_open");
    
    return ();
};

prove_dilithium dilithium2 1;
